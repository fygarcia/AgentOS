"""
PYDANTIC MODELS - Structured LLM I/O Schemas
=============================================

PURPOSE:
Define type-safe, validated data structures for LLM inputs and outputs.
Following LangChain best practices for structured output generation.

MODELS DEFINED:
1. PlanStep - Individual step in execution plan
2. Plan - Complete execution plan with metadata
3. AuditResult - Validation outcome from Auditor
4. CodeOutput - Executable code from Actor

DESIGN PRINCIPLES (LangChain Best Practices):
- ✅ Clear field descriptions guide model output
- ✅ Hierarchical structure (Plan → PlanStep)
- ✅ Optional fields for flexibility (reasoning, expected_outcome)
- ✅ Validation constraints via Literal types
- ✅ Auto-computed fields (total_steps)

SCHEMA HIERARCHY:
Plan
├── objective: str (overall goal)
├── plan: List[PlanStep] (ordered steps)
└── total_steps: int (auto-computed)

PlanStep
├── role: "Actor" | "Auditor" (who executes)
├── instruction: str (what to do)
├── reasoning: Optional[str] (why it's needed)
└── expected_outcome: Optional[str] (success criteria)

WHY THIS STRUCTURE:
- Supports both simple AND detailed planning
- Reasoning fields capture step-by-step thinking
- Optional fields don't break simple LLMs
- Validation ensures type safety

USAGE WITH TWO-STAGE CLIENT:
The two-stage client uses these schemas to validate parsed JSON:
1. gpt-oss:20b generates reasoning (fills all fields)
2. llama3.1:8b structures into Plan schema
3. Pydantic validates and returns typed object

PRODUCTION STATUS: ✅ Ready
RELATED: core/two_stage_client.py, core/nodes/planner.py
"""

from typing import List, Literal, Optional
from pydantic import BaseModel, Field, model_validator

class PlanStep(BaseModel):
    """A single step in the execution plan with reasoning."""
    role: Literal["Actor", "Auditor"] = Field(
        description="Who executes this step: Actor (performs actions) or Auditor (validates)"
    )
    instruction: str = Field(
        description="Clear, specific instruction for what to do in this step"
    )
    reasoning: Optional[str] = Field(
        default=None,
        description="Why this step is needed and how it contributes to the goal"
    )
    expected_outcome: Optional[str] = Field(
        default=None,
        description="What successful completion of this step looks like"
    )

class Plan(BaseModel):
    """Complete execution plan with metadata and ordered steps."""
    objective: str = Field(
        description="The overall goal this plan aims to achieve"
    )
    plan: List[PlanStep] = Field(
        description="Ordered list of steps to execute, from first to last"
    )
    total_steps: Optional[int] = Field(
        default=None,
        description="Total number of steps in the plan"
    )
    
    @model_validator(mode='after')
    def compute_total_steps(self):
        """Auto-compute total_steps if not provided (Pydantic V2 pattern)."""
        if self.total_steps is None:
            self.total_steps = len(self.plan)
        return self

class AuditResult(BaseModel):
    """Result of auditing a completed action."""
    passed: bool = Field(description="Whether the audit check passed")
    message: str = Field(description="Details about what was checked and the result")
    next_step: Literal["continue", "retry", "abort"] = Field(
        description="What to do next based on audit result"
    )

class CodeOutput(BaseModel):
    """Executable Python code generated by the Actor."""
    code: str = Field(description="Valid Python code to execute")
    explanation: str = Field(description="What this code does and why")
